<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  Class: Regexp
  
    &mdash; Documentation by YARD 0.9.25
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "Regexp";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index (R)</a> &raquo;
    
    
    <span class="title">Regexp</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><h1>Class: Regexp
  
  
  
</h1>
<div class="box_info">
  
  <dl>
    <dt>Inherits:</dt>
    <dd>
      <span class="inheritName"><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span>
      
        <ul class="fullTree">
          <li><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></li>
          
            <li class="next">Regexp</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
    </dd>
  </dl>
  

  
  
  
  
  

  

  
  <dl>
    <dt>Defined in:</dt>
    <dd>core/regexp.rbs</dd>
  </dl>
  
</div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    <p>A Regexp holds a regular expression, used to match a pattern against strings.
Regexps are created using the <code>/.../</code> and <code>%r{...}</code> literals, and by the
Regexp::new constructor.</p>

<p>Regular expressions (<em>regexp*s) are patterns which describe the contents of a
string. They&#39;re used for testing whether a string contains a given pattern, or
extracting the portions that match. They are created with the <code>/</code>*pat</em><code>/</code> and
<code>%r{</code><em>pat</em><code>}</code> literals or the <code>Regexp.new</code> constructor.</p>

<p>A regexp is usually delimited with forward slashes (<code>/</code>). For example:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>y</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;y&quot;&gt;
</span></code></pre>

<p>If a string contains the pattern it is said to <em>match</em>. A literal string
matches itself.</p>

<p>Here &#39;haystack&#39; does not contain the pattern &#39;needle&#39;, so it doesn&#39;t match:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>needle</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; nil
</span></code></pre>

<p>Here &#39;haystack&#39; contains the pattern &#39;hay&#39;, so it matches:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>    <span class='comment'>#=&gt; #&lt;MatchData &quot;hay&quot;&gt;
</span></code></pre>

<p>Specifically, <code>/st/</code> requires that the string contains the letter <em>s</em> followed
by the letter <em>t</em>, so it matches <em>haystack</em>, also.</p>

<h2 id="and-regexp-match"><code>=~</code> and Regexp#match</h2>

<p>Pattern matching may be achieved by using <code>=~</code> operator or Regexp#match
method.</p>

<h3 id="operator"><code>=~</code> operator</h3>

<p><code>=~</code> is Ruby&#39;s basic pattern-matching operator.  When one operand is a regular
expression and the other is a string then the regular expression is used as a
pattern to match against the string.  (This operator is equivalently defined
by Regexp and String so the order of String and Regexp do not matter. Other
classes may have different implementations of <code>=~</code>.)  If a match is found, the
operator returns index of first match in string, otherwise it returns <code>nil</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>hay</span><span class='regexp_end'>/</span></span>   <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span>   <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; 1
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>u</span><span class='regexp_end'>/</span></span>   <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span>   <span class='comment'>#=&gt; nil
</span></code></pre>

<p>Using <code>=~</code> operator with a String and Regexp the <code>$~</code> global variable is set
after a successful match.  <code>$~</code> holds a MatchData object. Regexp.last_match is
equivalent to <code>$~</code>.</p>

<h3 id="regexp-match-method">Regexp#match method</h3>

<p>The #match method returns a MatchData object:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>st</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>   <span class='comment'>#=&gt; #&lt;MatchData &quot;st&quot;&gt;
</span></code></pre>

<h2 id="metacharacters-and-escapes">Metacharacters and Escapes</h2>

<p>The following are <em>metacharacters</em> <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>{</code>, <code>}</code>, <code>.</code>, <code>?</code>,
<code>+</code>, <code>*</code>. They have a specific meaning when appearing in a pattern. To match
them literally they must be backslash-escaped. To match a backslash literally,
backslash-escape it: <code>\\\</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>1 \+ 2 = 3\?</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>Does 1 + 2 = 3?</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;1 + 2 = 3?&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a\\\\b</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a\\\\b</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>                    <span class='comment'>#=&gt; #&lt;MatchData &quot;a\\b&quot;&gt;
</span></code></pre>

<p>Patterns behave like double-quoted strings and can contain the same backslash
escapes (the meaning of <code>\s</code> is different, however, see
<a href="#label-Character+Classes">below</a>).</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\s\u{6771 4eac 90fd}</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Go to 東京都</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot; 東京都&quot;&gt;
</span></code></pre>

<p>Arbitrary Ruby expressions can be embedded into patterns with the <code>#{...}</code>
construct.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_place'>place</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>東京都</span><span class='tstring_end'>&quot;</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_place'>place</span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Go to 東京都</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;東京都&quot;&gt;
</span></code></pre>

<h2 id="character-classes">Character Classes</h2>

<p>A <em>character class</em> is delimited with square brackets (<code>[</code>, <code>]</code>) and lists
characters that may appear at that point in the match. <code>/[ab]/</code> means <em>a</em> or
<em>b</em>, as opposed to <code>/ab/</code> which means <em>a</em> followed by <em>b</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>W[aeiou]rd</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Word</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;Word&quot;&gt;
</span></code></pre>

<p>Within a character class the hyphen (<code>-</code>) is a metacharacter denoting an
inclusive range of characters. <code>[abcd]</code> is equivalent to <code>[a-d]</code>. A range can
be followed by another range, so <code>[abcdwxyz]</code> is equivalent to <code>[a-dw-z]</code>. The
order in which ranges or individual characters appear inside a character class
is irrelevant.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[0-9a-f]</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>9f</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;9&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[9f]</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>9f</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>     <span class='comment'>#=&gt; #&lt;MatchData &quot;9&quot;&gt;
</span></code></pre>

<p>If the first character of a character class is a caret (<code>^</code>) the class is
inverted: it matches any character <em>except</em> those named.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[^a-eg-z]</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>f</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;f&quot;&gt;
</span></code></pre>

<p>A character class may contain another character class. By itself this isn&#39;t
useful because <code>[a-z[0-9]]</code> describes the same set as <code>[a-z0-9]</code>. However,
character classes also support the <code>&amp;&amp;</code> operator which performs set
intersection on its arguments. The two can be combined as follows:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[a-w&amp;&amp;[^c-g]z]</span><span class='regexp_end'>/</span></span> <span class='comment'># ([a-w] AND ([^c-g] OR z))
</span></code></pre>

<p>This is equivalent to:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[abh-w]</span><span class='regexp_end'>/</span></span>
</code></pre>

<p>The following metacharacters also behave like character classes:</p>

<ul>
<li>  <code>/./</code> - Any character except a newline.</li>
<li>  <code>/./m</code> - Any character (the <code>m</code> modifier enables multiline mode)</li>
<li>  <code>/\w/</code> - A word character (<code>[a-zA-Z0-9_]</code>)</li>
<li>  <code>/\W/</code> - A non-word character (<code>[^a-zA-Z0-9_]</code>). Please take a look at
<a href="https://bugs.ruby-lang.org/issues/4044">Bug #4044</a> if using <code>/\W/</code> with
the <code>/i</code> modifier.</li>
<li>  <code>/\d/</code> - A digit character (<code>[0-9]</code>)</li>
<li>  <code>/\D/</code> - A non-digit character (<code>[^0-9]</code>)</li>
<li>  <code>/\h/</code> - A hexdigit character (<code>[0-9a-fA-F]</code>)</li>
<li>  <code>/\H/</code> - A non-hexdigit character (<code>[^0-9a-fA-F]</code>)</li>
<li>  <code>/\s/</code> - A whitespace character: <code>/[ \t\r\n\f\v]/</code></li>
<li>  <code>/\S/</code> - A non-whitespace character: <code>/[^ \t\r\n\f\v]/</code></li>
<li>  <code>/\R/</code> - A linebreak: <code>\n</code>, <code>\v</code>, <code>\f</code>, <code>\r</code> <code>\u0085</code> (NEXT LINE),
<code>\u2028</code> (LINE SEPARATOR), <code>\u2029</code> (PARAGRAPH SEPARATOR) or <code>\r\n</code>.</li>
</ul>

<p>POSIX <em>bracket expressions</em> are also similar to character classes. They
provide a portable alternative to the above, with the added benefit that they
encompass non-ASCII characters. For instance, <code>/\d/</code> matches only the ASCII
decimal digits (0-9); whereas <code>/[[:digit:]]/</code> matches any character in the
Unicode <em>Nd</em> category.</p>

<ul>
<li>  <code>/[[:alnum:]]/</code> - Alphabetic and numeric character</li>
<li>  <code>/[[:alpha:]]/</code> - Alphabetic character</li>
<li>  <code>/[[:blank:]]/</code> - Space or tab</li>
<li>  <code>/[[:cntrl:]]/</code> - Control character</li>
<li>  <code>/[[:digit:]]/</code> - Digit</li>
<li>  <code>/[[:graph:]]/</code> - Non-blank character (excludes spaces, control
characters, and similar)</li>
<li>  <code>/[[:lower:]]/</code> - Lowercase alphabetical character</li>
<li>  <code>/[[:print:]]/</code> - Like [:graph:], but includes the space character</li>
<li>  <code>/[[:punct:]]/</code> - Punctuation character</li>
<li>  <code>/[[:space:]]/</code> - Whitespace character (<code>[:blank:]</code>, newline, carriage
return, etc.)</li>
<li>  <code>/[[:upper:]]/</code> - Uppercase alphabetical</li>
<li>  <code>/[[:xdigit:]]/</code> - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)</li>
</ul>

<p>Ruby also supports the following non-POSIX character classes:</p>

<ul>
<li>  <code>/[[:word:]]/</code> - A character in one of the following Unicode general
categories <em>Letter</em>, <em>Mark</em>, <em>Number</em>, <em>Connector_Punctuation</em></li>
<li><p><code>/[[:ascii:]]/</code> - A character in the ASCII character set</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># U+06F2 is &quot;EXTENDED ARABIC-INDIC DIGIT TWO&quot;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:digit:]]</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u06F2</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>    <span class='comment'>#=&gt; #&lt;MatchData &quot;\u{06F2}&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:upper:]][[:lower:]]</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;He&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:xdigit:]][[:xdigit:]]</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>A6</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>  <span class='comment'>#=&gt; #&lt;MatchData &quot;A6&quot;&gt;
</span></code></pre></li>
</ul>

<h2 id="repetition">Repetition</h2>

<p>The constructs described so far match a single character. They can be followed
by a repetition metacharacter to specify how many times they need to occur.
Such metacharacters are called <em>quantifiers</em>.</p>

<ul>
<li>  <code>*</code> - Zero or more times</li>
<li>  <code>+</code> - One or more times</li>
<li>  <code>?</code> - Zero or one times (optional)</li>
<li>  <code>{</code><em>n</em><code>}</code> - Exactly <em>n</em> times</li>
<li>  <code>{</code><em>n</em><code>,}</code> - <em>n</em> or more times</li>
<li>  <code>{,</code><em>m</em><code>}</code> - <em>m</em> or less times</li>
<li>  <code>{</code><em>n</em><code>,</code><em>m</em><code>}</code> - At least <em>n</em> and at most <em>m</em> times</li>
</ul>

<p>At least one uppercase character (&#39;H&#39;), at least one lowercase character
(&#39;e&#39;), two &#39;l&#39; characters, then one &#39;o&#39;:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[[:upper:]]+[[:lower:]]+l{2}o</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;Hello&quot;&gt;
</span></code></pre>

<p>Repetition is <em>greedy</em> by default: as many occurrences as possible are matched
while still allowing the overall match to succeed. By contrast, <em>lazy</em>
matching makes the minimal amount of matches necessary for overall success.
Most greedy metacharacters can be made lazy by following them with <code>?</code>. For
the <code>{n}</code> pattern, because it specifies an exact number of characters to match
and not a variable number of characters, the <code>?</code> metacharacter instead makes
the repeated pattern optional.</p>

<p>Both patterns below match the string. The first uses a greedy quantifier so
&#39;.+&#39; matches &#39;<a><b>&#39;; the second uses a lazy quantifier so &#39;.+?&#39; matches
&#39;<a>&#39;:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.+&gt;</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>  <span class='comment'>#=&gt; #&lt;MatchData &quot;&lt;a&gt;&lt;b&gt;&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&lt;.+?&gt;</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>&lt;a&gt;&lt;b&gt;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;&lt;a&gt;&quot;&gt;
</span></code></pre>

<p>A quantifier followed by <code>+</code> matches <em>possessively</em>: once it has matched it
does not backtrack. They behave like greedy quantifiers, but having matched
they refuse to &quot;give up&quot; their match even if this jeopardises the overall
match.</p>

<h2 id="capturing">Capturing</h2>

<p>Parentheses can be used for <em>capturing</em>. The text enclosed by the
<em>n</em><sup>th</sup> group of parentheses can be subsequently referred to with
<em>n</em>. Within a pattern use the <em>backreference</em> <code>\n</code>; outside of the pattern use
<code>MatchData[n]</code>.</p>

<p>&#39;at&#39; is captured by the first group of parentheses, then referred to later
with <code>\1</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[csh](..) [csh]\1 in</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>The cat sat in the hat</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;cat sat in&quot; 1:&quot;at&quot;&gt;
</span></code></pre>

<p>Regexp#match returns a MatchData object which makes the captured text
available with its #[] method:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[csh](..) [csh]\1 in</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>The cat sat in the hat</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span> <span class='comment'>#=&gt; &#39;at&#39;
</span></code></pre>

<p>Capture groups can be referred to by name when defined with the
<code>(?&lt;</code><em>name</em><code>&gt;)</code> or <code>(?&#39;</code><em>name</em><code>&#39;)</code> constructs.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$3.67</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;$3.67&quot; dollars:&quot;3&quot; cents:&quot;67&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$3.67</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='symbol'>:dollars</span><span class='rbracket'>]</span> <span class='comment'>#=&gt; &quot;3&quot;
</span></code></pre>

<p>Named groups can be backreferenced with <code>\k&lt;</code><em>name</em><code>&gt;</code>, where <em>name</em> is the
group name.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;vowel&gt;[aeiou]).\k&lt;vowel&gt;.\k&lt;vowel&gt;</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ototomy</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;ototo&quot; vowel:&quot;o&quot;&gt;
</span></code></pre>

<p><strong>Note</strong>: A regexp can&#39;t use named backreferences and numbered backreferences
simultaneously. Also, if a named capture is used in a regexp, then parentheses
used for grouping which would otherwise result in a unnamed capture are
treated as non-capturing.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(\w)(\w)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_captures'>captures</span> <span class='comment'># =&gt; [&quot;a&quot;, &quot;b&quot;]
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(\w)(\w)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_named_captures'>named_captures</span> <span class='comment'># =&gt; {}
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;c&gt;\w)(\w)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_captures'>captures</span> <span class='comment'># =&gt; [&quot;a&quot;]
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;c&gt;\w)(\w)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>ab</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_named_captures'>named_captures</span> <span class='comment'># =&gt; {&quot;c&quot;=&gt;&quot;a&quot;}
</span></code></pre>

<p>When named capture groups are used with a literal regexp on the left-hand side
of an expression and the <code>=~</code> operator, the captured text is also assigned to
local variables with corresponding names.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\$(?&lt;dollars&gt;\d+)\.(?&lt;cents&gt;\d+)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>$3.67</span><span class='tstring_end'>&quot;</span></span> <span class='comment'>#=&gt; 0
</span><span class='id identifier rubyid_dollars'>dollars</span> <span class='comment'>#=&gt; &quot;3&quot;
</span></code></pre>

<h2 id="grouping">Grouping</h2>

<p>Parentheses also <em>group</em> the terms they enclose, allowing them to be
quantified as one <em>atomic</em> whole.</p>

<p>The pattern below matches a vowel followed by 2 word characters:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>[aeiou]\w{2}</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Caenorhabditis elegans</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;aen&quot;&gt;
</span></code></pre>

<p>Whereas the following pattern matches a vowel followed by a word character,
twice, i.e. <code>[aeiou]\w[aeiou]\w</code>: &#39;enor&#39;.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>([aeiou]\w){2}</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Caenorhabditis elegans</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;enor&quot; 1:&quot;or&quot;&gt;
</span></code></pre>

<p>The <code>(?:</code>...<code>)</code> construct provides grouping without capturing. That is, it
combines the terms it contains into an atomic whole without creating a
backreference. This benefits performance at the slight expense of readability.</p>

<p>The first group of parentheses captures &#39;n&#39; and the second &#39;ti&#39;. The second
group is referred to later with the backreference <code>\2</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>I(n)ves(ti)ga\2ons</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Investigations</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;Investigations&quot; 1:&quot;n&quot; 2:&quot;ti&quot;&gt;
</span></code></pre>

<p>The first group of parentheses is now made non-capturing with &#39;?:&#39;, so it
still matches &#39;n&#39;, but doesn&#39;t create the backreference. Thus, the
backreference <code>\1</code> now refers to &#39;ti&#39;.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>I(?:n)ves(ti)ga\1ons</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Investigations</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;Investigations&quot; 1:&quot;ti&quot;&gt;
</span></code></pre>

<h3 id="atomic-grouping">Atomic Grouping</h3>

<p>Grouping can be made <em>atomic</em> with <code>(?&gt;</code><em>pat</em><code>)</code>. This causes the
subexpression <em>pat</em> to be matched independently of the rest of the expression
such that what it matches becomes fixed for the remainder of the match, unless
the entire subexpression must be abandoned and subsequently revisited. In this
way <em>pat</em> is treated as a non-divisible whole. Atomic grouping is typically
used to optimise patterns so as to prevent the regular expression engine from
backtracking needlessly.</p>

<p>The <code>&quot;</code> in the pattern below matches the first character of the string, then
<code>.*</code> matches <em>Quote&quot;</em>. This causes the overall match to fail, so the text
matched by <code>.*</code> is backtracked by one position, which leaves the final
character of the string available to match <code>&quot;</code></p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&quot;.*&quot;</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>&quot;Quote&quot;</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>     <span class='comment'>#=&gt; #&lt;MatchData &quot;\&quot;Quote\&quot;&quot;&gt;
</span></code></pre>

<p>If <code>.*</code> is grouped atomically, it refuses to backtrack <em>Quote&quot;</em>, even though
this means that the overall match fails</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>&quot;(?&gt;.*)&quot;</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>&quot;Quote&quot;</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; nil
</span></code></pre>

<h2 id="subexpression-calls">Subexpression Calls</h2>

<p>The <code>\g&lt;</code><em>name</em><code>&gt;</code> syntax matches the previous subexpression named <em>name</em>,
which can be a group name or number, again. This differs from backreferences
in that it re-executes the group rather than simply trying to re-match the
same text.</p>

<p>This pattern matches a <em>(</em> character and assigns it to the <code>paren</code> group,
tries to call that the <code>paren</code> sub-expression again but fails, then matches a
literal <em>)</em>:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>()</span><span class='tstring_end'>&#39;</span></span>

<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A(?&lt;paren&gt;\(\g&lt;paren&gt;*\))*\z</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>(())</span><span class='tstring_end'>&#39;</span></span> <span class='comment'>#=&gt; 0
</span><span class='comment'># ^1
</span><span class='comment'>#      ^2
</span><span class='comment'>#           ^3
</span><span class='comment'>#                 ^4
</span><span class='comment'>#      ^5
</span><span class='comment'>#           ^6
</span><span class='comment'>#                      ^7
</span><span class='comment'>#                       ^8
</span><span class='comment'>#                       ^9
</span><span class='comment'>#                           ^10
</span></code></pre>

<ol>
<li> Matches at the beginning of the string, i.e. before the first character.</li>
<li> Enters a named capture group called <code>paren</code></li>
<li> Matches a literal <em>(</em>, the first character in the string</li>
<li> Calls the <code>paren</code> group again, i.e. recurses back to the second step</li>
<li> Re-enters the <code>paren</code> group</li>
<li> Matches a literal <em>(</em>, the second character in the string</li>
<li> Try to call <code>paren</code> a third time, but fail because doing so would prevent
an overall successful match</li>
<li> Match a literal <em>)</em>, the third character in the string. Marks the end of
the second recursive call</li>
<li> Match a literal <em>)</em>, the fourth character in the string</li>
<li>Match the end of the string</li>
</ol>

<h2 id="alternation">Alternation</h2>

<p>The vertical bar metacharacter (<code>|</code>) combines two expressions into a single
one that matches either of the expressions. Each expression is an
<em>alternative</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w(and|or)\w</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Feliformia</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;form&quot; 1:&quot;or&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w(and|or)\w</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>furandi</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>    <span class='comment'>#=&gt; #&lt;MatchData &quot;randi&quot; 1:&quot;and&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\w(and|or)\w</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>dissemblance</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; nil
</span></code></pre>

<h2 id="character-properties">Character Properties</h2>

<p>The <code>\p{}</code> construct matches characters with the named property, much like
POSIX bracket classes.</p>

<ul>
<li>  <code>/\p{Alnum}/</code> - Alphabetic and numeric character</li>
<li>  <code>/\p{Alpha}/</code> - Alphabetic character</li>
<li>  <code>/\p{Blank}/</code> - Space or tab</li>
<li>  <code>/\p{Cntrl}/</code> - Control character</li>
<li>  <code>/\p{Digit}/</code> - Digit</li>
<li>  <code>/\p{Graph}/</code> - Non-blank character (excludes spaces, control characters,
and similar)</li>
<li>  <code>/\p{Lower}/</code> - Lowercase alphabetical character</li>
<li>  <code>/\p{Print}/</code> - Like <code>\p{Graph}</code>, but includes the space character</li>
<li>  <code>/\p{Punct}/</code> - Punctuation character</li>
<li>  <code>/\p{Space}/</code> - Whitespace character (<code>[:blank:]</code>, newline, carriage
return, etc.)</li>
<li>  <code>/\p{Upper}/</code> - Uppercase alphabetical</li>
<li>  <code>/\p{XDigit}/</code> - Digit allowed in a hexadecimal number (i.e., 0-9a-fA-F)</li>
<li>  <code>/\p{Word}/</code> - A member of one of the following Unicode general category
<em>Letter</em>, <em>Mark</em>, <em>Number</em>, <em>Connector_Punctuation</em></li>
<li>  <code>/\p{ASCII}/</code> - A character in the ASCII character set</li>
<li>  <code>/\p{Any}/</code> - Any Unicode character (including unassigned characters)</li>
<li>  <code>/\p{Assigned}/</code> - An assigned character</li>
</ul>

<p>A Unicode character&#39;s <em>General Category</em> value can also be matched with
<code>\p{</code><em>Ab</em><code>}</code> where <em>Ab</em> is the category&#39;s abbreviation as described below:</p>

<ul>
<li>  <code>/\p{L}/</code> - &#39;Letter&#39;</li>
<li>  <code>/\p{Ll}/</code> - &#39;Letter: Lowercase&#39;</li>
<li>  <code>/\p{Lm}/</code> - &#39;Letter: Mark&#39;</li>
<li>  <code>/\p{Lo}/</code> - &#39;Letter: Other&#39;</li>
<li>  <code>/\p{Lt}/</code> - &#39;Letter: Titlecase&#39;</li>
<li>  <code>/\p{Lu}/</code> - &#39;Letter: Uppercase</li>
<li>  <code>/\p{Lo}/</code> - &#39;Letter: Other&#39;</li>
<li>  <code>/\p{M}/</code> - &#39;Mark&#39;</li>
<li>  <code>/\p{Mn}/</code> - &#39;Mark: Nonspacing&#39;</li>
<li>  <code>/\p{Mc}/</code> - &#39;Mark: Spacing Combining&#39;</li>
<li>  <code>/\p{Me}/</code> - &#39;Mark: Enclosing&#39;</li>
<li>  <code>/\p{N}/</code> - &#39;Number&#39;</li>
<li>  <code>/\p{Nd}/</code> - &#39;Number: Decimal Digit&#39;</li>
<li>  <code>/\p{Nl}/</code> - &#39;Number: Letter&#39;</li>
<li>  <code>/\p{No}/</code> - &#39;Number: Other&#39;</li>
<li>  <code>/\p{P}/</code> - &#39;Punctuation&#39;</li>
<li>  <code>/\p{Pc}/</code> - &#39;Punctuation: Connector&#39;</li>
<li>  <code>/\p{Pd}/</code> - &#39;Punctuation: Dash&#39;</li>
<li>  <code>/\p{Ps}/</code> - &#39;Punctuation: Open&#39;</li>
<li>  <code>/\p{Pe}/</code> - &#39;Punctuation: Close&#39;</li>
<li>  <code>/\p{Pi}/</code> - &#39;Punctuation: Initial Quote&#39;</li>
<li>  <code>/\p{Pf}/</code> - &#39;Punctuation: Final Quote&#39;</li>
<li>  <code>/\p{Po}/</code> - &#39;Punctuation: Other&#39;</li>
<li>  <code>/\p{S}/</code> - &#39;Symbol&#39;</li>
<li>  <code>/\p{Sm}/</code> - &#39;Symbol: Math&#39;</li>
<li>  <code>/\p{Sc}/</code> - &#39;Symbol: Currency&#39;</li>
<li>  <code>/\p{Sc}/</code> - &#39;Symbol: Currency&#39;</li>
<li>  <code>/\p{Sk}/</code> - &#39;Symbol: Modifier&#39;</li>
<li>  <code>/\p{So}/</code> - &#39;Symbol: Other&#39;</li>
<li>  <code>/\p{Z}/</code> - &#39;Separator&#39;</li>
<li>  <code>/\p{Zs}/</code> - &#39;Separator: Space&#39;</li>
<li>  <code>/\p{Zl}/</code> - &#39;Separator: Line&#39;</li>
<li>  <code>/\p{Zp}/</code> - &#39;Separator: Paragraph&#39;</li>
<li>  <code>/\p{C}/</code> - &#39;Other&#39;</li>
<li>  <code>/\p{Cc}/</code> - &#39;Other: Control&#39;</li>
<li>  <code>/\p{Cf}/</code> - &#39;Other: Format&#39;</li>
<li>  <code>/\p{Cn}/</code> - &#39;Other: Not Assigned&#39;</li>
<li>  <code>/\p{Co}/</code> - &#39;Other: Private Use&#39;</li>
<li>  <code>/\p{Cs}/</code> - &#39;Other: Surrogate&#39;</li>
</ul>

<p>Lastly, <code>\p{}</code> matches a character&#39;s Unicode <em>script</em>. The following scripts
are supported: <em>Arabic</em>, <em>Armenian</em>, <em>Balinese</em>, <em>Bengali</em>, <em>Bopomofo</em>,
<em>Braille</em>, <em>Buginese</em>, <em>Buhid</em>, <em>Canadian_Aboriginal</em>, <em>Carian</em>, <em>Cham</em>,
<em>Cherokee</em>, <em>Common</em>, <em>Coptic</em>, <em>Cuneiform</em>, <em>Cypriot</em>, <em>Cyrillic</em>, <em>Deseret</em>,
<em>Devanagari</em>, <em>Ethiopic</em>, <em>Georgian</em>, <em>Glagolitic</em>, <em>Gothic</em>, <em>Greek</em>,
<em>Gujarati</em>, <em>Gurmukhi</em>, <em>Han</em>, <em>Hangul</em>, <em>Hanunoo</em>, <em>Hebrew</em>, <em>Hiragana</em>,
<em>Inherited</em>, <em>Kannada</em>, <em>Katakana</em>, <em>Kayah_Li</em>, <em>Kharoshthi</em>, <em>Khmer</em>, <em>Lao</em>,
<em>Latin</em>, <em>Lepcha</em>, <em>Limbu</em>, <em>Linear_B</em>, <em>Lycian</em>, <em>Lydian</em>, <em>Malayalam</em>,
<em>Mongolian</em>, <em>Myanmar</em>, <em>New_Tai_Lue</em>, <em>Nko</em>, <em>Ogham</em>, <em>Ol_Chiki</em>,
<em>Old_Italic</em>, <em>Old_Persian</em>, <em>Oriya</em>, <em>Osmanya</em>, <em>Phags_Pa</em>, <em>Phoenician</em>,
<em>Rejang</em>, <em>Runic</em>, <em>Saurashtra</em>, <em>Shavian</em>, <em>Sinhala</em>, <em>Sundanese</em>,
<em>Syloti_Nagri</em>, <em>Syriac</em>, <em>Tagalog</em>, <em>Tagbanwa</em>, <em>Tai_Le</em>, <em>Tamil</em>, <em>Telugu</em>,
<em>Thaana</em>, <em>Thai</em>, <em>Tibetan</em>, <em>Tifinagh</em>, <em>Ugaritic</em>, <em>Vai</em>, and <em>Yi</em>.</p>

<p>Unicode codepoint U+06E9 is named &quot;ARABIC PLACE OF SAJDAH&quot; and belongs to the
Arabic script:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\p{Arabic}</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u06E9</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;\u06E9&quot;&gt;
</span></code></pre>

<p>All character properties can be inverted by prefixing their name with a caret
(<code>^</code>).</p>

<p>Letter &#39;A&#39; is not in the Unicode Ll (Letter; Lowercase) category, so this
match succeeds:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\p{^Ll}</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>A</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;A&quot;&gt;
</span></code></pre>

<h2 id="anchors">Anchors</h2>

<p>Anchors are metacharacter that match the zero-width positions between
characters, <em>anchoring</em> the match to a specific position.</p>

<ul>
<li>  <code>^</code> - Matches beginning of line</li>
<li>  <code>$</code> - Matches end of line</li>
<li>  <code>\A</code> - Matches beginning of string.</li>
<li>  <code>\Z</code> - Matches end of string. If string ends with a newline, it matches
just before newline</li>
<li>  <code>\z</code> - Matches end of string</li>
<li><p><code>\G</code> - Matches first matching position:</p>

<p>In methods like <code>String#gsub</code> and <code>String#scan</code>, it changes on each
iteration. It initially matches the beginning of subject, and in each
following iteration it matches where the last match finished.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>    a b c</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_gsub'>gsub</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'> </span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>_</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>    <span class='comment'>#=&gt; &quot;____a_b_c&quot;
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>    a b c</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_gsub'>gsub</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\G </span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>_</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>  <span class='comment'>#=&gt; &quot;____a b c&quot;
</span></code></pre>

<p>In methods like <code>Regexp#match</code> and <code>String#match</code> that take an (optional)
offset, it matches where the search begins.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello, world</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>,</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>3</span><span class='rparen'>)</span>    <span class='comment'>#=&gt; #&lt;MatchData &quot;,&quot;&gt;
</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>hello, world</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\G,</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='int'>3</span><span class='rparen'>)</span>  <span class='comment'>#=&gt; nil
</span></code></pre></li>
<li><p><code>\b</code> - Matches word boundaries when outside brackets; backspace (0x08)
when inside brackets</p></li>
<li><p><code>\B</code> - Matches non-word boundaries</p></li>
<li><p><code>(?=</code><em>pat</em><code>)</code> - <em>Positive lookahead</em> assertion: ensures that the following
characters match <em>pat</em>, but doesn&#39;t include those characters in the
matched text</p></li>
<li><p><code>(?!</code><em>pat</em><code>)</code> - <em>Negative lookahead</em> assertion: ensures that the following
characters do not match <em>pat</em>, but doesn&#39;t include those characters in the
matched text</p></li>
<li><p><code>(?&lt;=</code><em>pat</em><code>)</code> - <em>Positive lookbehind</em> assertion: ensures that the
preceding characters match <em>pat</em>, but doesn&#39;t include those characters in
the matched text</p></li>
<li><p><code>(?&lt;!</code><em>pat</em><code>)</code> - <em>Negative lookbehind</em> assertion: ensures that the
preceding characters do not match <em>pat</em>, but doesn&#39;t include those
characters in the matched text</p></li>
</ul>

<p>If a pattern isn&#39;t anchored it can begin at any point in the string:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>real</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>surrealist</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;real&quot;&gt;
</span></code></pre>

<p>Anchoring the pattern to the beginning of the string forces the match to start
there. &#39;real&#39; doesn&#39;t occur at the beginning of the string, so now the match
fails:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\Areal</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>surrealist</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; nil
</span></code></pre>

<p>The match below fails because although &#39;Demand&#39; contains &#39;and&#39;, the pattern
does not occur at a word boundary.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\band</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Demand</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
</code></pre>

<p>Whereas in the following example &#39;and&#39; has been anchored to a non-word
boundary so instead of matching the first &#39;and&#39; it matches from the fourth
letter of &#39;demand&#39; instead:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\Band.+</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Supply and demand curve</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;and curve&quot;&gt;
</span></code></pre>

<p>The pattern below uses positive lookahead and positive lookbehind to match
text appearing in  tags without including the tags in the match:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;=&lt;b&gt;)\w+(?=&lt;\/b&gt;)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Fortune favours the &lt;b&gt;bold&lt;/b&gt;</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
    <span class='comment'>#=&gt; #&lt;MatchData &quot;bold&quot;&gt;
</span></code></pre>

<h2 id="options">Options</h2>

<p>The end delimiter for a regexp can be followed by one or more single-letter
options which control how the pattern can match.</p>

<ul>
<li>  <code>/pat/i</code> - Ignore case</li>
<li>  <code>/pat/m</code> - Treat a newline as a character matched by <code>.</code></li>
<li>  <code>/pat/x</code> - Ignore whitespace and comments in the pattern</li>
<li>  <code>/pat/o</code> - Perform <code>#{}</code> interpolation only once</li>
</ul>

<p><code>i</code>, <code>m</code>, and <code>x</code> can also be applied on the subexpression level with the
<code>(?</code><em>on</em><code>-</code><em>off</em><code>)</code> construct, which enables options <em>on</em>, and disables
options <em>off</em> for the expression enclosed by the parentheses:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a(?i:b)c</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>aBc</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>   <span class='comment'>#=&gt; #&lt;MatchData &quot;aBc&quot;&gt;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a(?-i:b)c</span><span class='regexp_end'>/i</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>ABC</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; nil
</span></code></pre>

<p>Additionally, these options can also be toggled for the remainder of the
pattern:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a(?i)bc</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>abC</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;abC&quot;&gt;
</span></code></pre>

<p>Options may also be used with <code>Regexp.new</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span></span><span class='rparen'>)</span>                     <span class='comment'>#=&gt; /abc/i
</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span></span><span class='rparen'>)</span>                      <span class='comment'>#=&gt; /abc/m
</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc # Comment</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span></span><span class='rparen'>)</span>             <span class='comment'>#=&gt; /abc # Comment/x
</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span></span> <span class='op'>|</span> <span class='const'>Regexp</span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; /abc/mi
</span></code></pre>

<h2 id="free-spacing-mode-and-comments">Free-Spacing Mode and Comments</h2>

<p>As mentioned above, the <code>x</code> option enables <em>free-spacing</em> mode. Literal white
space inside the pattern is ignored, and the octothorpe (<code>#</code>) character
introduces a comment until the end of the line. This allows the components of
the pattern to be organized in a potentially more readable fashion.</p>

<p>A contrived pattern to match a number with optional decimal places:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_float_pat'>float_pat</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A
    [[:digit:]]+ # 1 or more digits before the decimal point
    (\.          # Decimal point
        [[:digit:]]+ # 1 or more digits after the decimal point
    )? # The decimal point and following digits are optional
\Z</span><span class='regexp_end'>/x</span></span>
<span class='id identifier rubyid_float_pat'>float_pat</span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>3.14</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;3.14&quot; 1:&quot;.14&quot;&gt;
</span></code></pre>

<p>There are a number of strategies for matching whitespace:</p>

<ul>
<li>  Use a pattern such as <code>\s</code> or <code>\p{Space}</code>.</li>
<li>  Use escaped whitespace such as <code>\</code>, i.e. a space preceded by a backslash.</li>
<li>  Use a character class such as <code>[ ]</code>.</li>
</ul>

<p>Comments can be included in a non-<code>x</code> pattern with the <code>(?#</code><em>comment</em><code>)</code>
construct, where <em>comment</em> is arbitrary text ignored by the regexp engine.</p>

<p>Comments in regexp literals cannot include unescaped terminator characters.</p>

<h2 id="encoding">Encoding</h2>

<p>Regular expressions are assumed to use the source encoding. This can be
overridden with one of the following modifiers.</p>

<ul>
<li>  <code>/</code><em>pat</em><code>/u</code> - UTF-8</li>
<li>  <code>/</code><em>pat</em><code>/e</code> - EUC-JP</li>
<li>  <code>/</code><em>pat</em><code>/s</code> - Windows-31J</li>
<li>  <code>/</code><em>pat</em><code>/n</code> - ASCII-8BIT</li>
</ul>

<p>A regexp can be matched against a string when they either share an encoding,
or the regexp&#39;s encoding is <em>US-ASCII</em> and the string&#39;s encoding is
ASCII-compatible.</p>

<p>If a match between incompatible encodings is attempted an
<code>Encoding::CompatibilityError</code> exception is raised.</p>

<p>The <code>Regexp#fixed_encoding?</code> predicate indicates whether the regexp has a
<em>fixed</em> encoding, that is one incompatible with ASCII. A regexp&#39;s encoding can
be explicitly fixed by supplying <code>Regexp::FIXEDENCODING</code> as the second
argument of <code>Regexp.new</code>:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>iso-8859-1</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='comma'>,</span><span class='const'>Regexp</span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#FIXEDENCODING-constant" title="Regexp::FIXEDENCODING (constant)">FIXEDENCODING</a></span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a\u3042</span><span class='tstring_end'>&quot;</span></span>
   <span class='comment'># raises Encoding::CompatibilityError: incompatible encoding regexp match
</span>   <span class='comment'>#         (ISO-8859-1 regexp with UTF-8 string)
</span></code></pre>

<h2 id="special-global-variables">Special global variables</h2>

<p>Pattern matching sets some global variables :</p>

<ul>
<li>  <code>$~</code> is equivalent to Regexp.last_match;</li>
<li>  <code>$&amp;</code> contains the complete matched text;</li>
<li>  <code>$</code>` contains string before match;</li>
<li>  <code>$&#39;</code> contains string after match;</li>
<li>  <code>$1</code>, <code>$2</code> and so on contain text matching first, second, etc capture
group;</li>
<li>  <code>$+</code> contains last capture group.</li>
</ul>

<p>Example:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_m'>m</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>s(\w{2}).*(c)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>haystack</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; #&lt;MatchData &quot;stac&quot; 1:&quot;ta&quot; 2:&quot;c&quot;&gt;
</span><span class='gvar'>$~</span>                                    <span class='comment'>#=&gt; #&lt;MatchData &quot;stac&quot; 1:&quot;ta&quot; 2:&quot;c&quot;&gt;
</span><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_last_match'><span class='object_link'><a href="#last_match-class_method" title="Regexp.last_match (method)">last_match</a></span></span>                     <span class='comment'>#=&gt; #&lt;MatchData &quot;stac&quot; 1:&quot;ta&quot; 2:&quot;c&quot;&gt;
</span>
<span class='backref'>$&amp;</span>      <span class='comment'>#=&gt; &quot;stac&quot;
</span>        <span class='comment'># same as m[0]
</span><span class='backref'>$`</span>      <span class='comment'>#=&gt; &quot;hay&quot;
</span>        <span class='comment'># same as m.pre_match
</span><span class='backref'>$&#39;</span>      <span class='comment'>#=&gt; &quot;k&quot;
</span>        <span class='comment'># same as m.post_match
</span><span class='backref'>$1</span>      <span class='comment'>#=&gt; &quot;ta&quot;
</span>        <span class='comment'># same as m[1]
</span><span class='backref'>$2</span>      <span class='comment'>#=&gt; &quot;c&quot;
</span>        <span class='comment'># same as m[2]
</span><span class='backref'>$3</span>      <span class='comment'>#=&gt; nil
</span>        <span class='comment'># no third group in pattern
</span><span class='backref'>$+</span>      <span class='comment'>#=&gt; &quot;c&quot;
</span>        <span class='comment'># same as m[-1]
</span></code></pre>

<p>These global variables are thread-local and method-local variables.</p>

<h2 id="performance">Performance</h2>

<p>Certain pathological combinations of constructs can lead to abysmally bad
performance.</p>

<p>Consider a string of 25 <em>a*s, a *d</em>, 4 <em>a*s, and a *c</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_s'>s</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>25</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>d</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>4</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>c</span><span class='tstring_end'>&#39;</span></span>
<span class='comment'>#=&gt; &quot;aaaaaaaaaaaaaaaaaaaaaaaaadaaaac&quot;
</span></code></pre>

<p>The following patterns match instantly as you would expect:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 0
</span></code></pre>

<p>However, the following pattern takes appreciably longer:</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='comment'>#=&gt; 26
</span></code></pre>

<p>This happens because an atom in the regexp is quantified by both an immediate
<code>+</code> and an enclosing <code>*</code> with nothing to differentiate which is in control of
any particular character. The nondeterminism that results produces
super-linear performance. (Consult <em>Mastering Regular Expressions</em> (3rd ed.),
pp 222, by <em>Jeffery Friedl</em>, for an in-depth analysis). This particular case
can be fixed by use of atomic grouping, which prevents the unnecessary
backtracking:</p>

<pre class="code ruby"><code class="ruby"><span class='lparen'>(</span><span class='id identifier rubyid_start'>start</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Time.html" title="Time (class)">Time</a></span></span><span class='period'>.</span><span class='id identifier rubyid_now'><span class='object_link'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span></span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> <span class='lparen'>(</span><span class='const'><span class='object_link'><a href="Time.html" title="Time (class)">Time</a></span></span><span class='period'>.</span><span class='id identifier rubyid_now'><span class='object_link'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span></span> <span class='op'>-</span> <span class='id identifier rubyid_start'>start</span><span class='rparen'>)</span>
   <span class='comment'>#=&gt; 24.702736882
</span><span class='lparen'>(</span><span class='id identifier rubyid_start'>start</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Time.html" title="Time (class)">Time</a></span></span><span class='period'>.</span><span class='id identifier rubyid_now'><span class='object_link'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span></span><span class='rparen'>)</span> <span class='op'>&amp;&amp;</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&gt;b|a+)*c</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='id identifier rubyid_s'>s</span> <span class='op'>&amp;&amp;</span> <span class='lparen'>(</span><span class='const'><span class='object_link'><a href="Time.html" title="Time (class)">Time</a></span></span><span class='period'>.</span><span class='id identifier rubyid_now'><span class='object_link'><a href="Time.html#now-class_method" title="Time.now (method)">now</a></span></span> <span class='op'>-</span> <span class='id identifier rubyid_start'>start</span><span class='rparen'>)</span>
   <span class='comment'>#=&gt; 0.000166571
</span></code></pre>

<p>A similar case is typified by the following example, which takes approximately
60 seconds to execute for me:</p>

<p>Match a string of 29 *a*s against a pattern of 29 optional *a*s followed by 29
mandatory *a*s:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a?</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span><span class='rparen'>)</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span>
</code></pre>

<p>The 29 optional *a*s match the string, but this prevents the 29 mandatory *a*s
that follow from matching. Ruby must then backtrack repeatedly so as to
satisfy as many of the optional matches as it can while still matching the
mandatory 29. It is plain to us that none of the optional matches can succeed,
but this fact unfortunately eludes Ruby.</p>

<p>The best way to improve performance is to significantly reduce the amount of
backtracking needed.  For this case, instead of individually matching 29
optional <em>a*s, a range of optional *a*s can be matched all at once with
*a0,29</em>:</p>

<pre class="code ruby"><code class="ruby"><span class='const'>Regexp</span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a{0,29}</span><span class='tstring_end'>&#39;</span></span> <span class='op'>+</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span><span class='rparen'>)</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>a</span><span class='tstring_end'>&#39;</span></span> <span class='op'>*</span> <span class='int'>29</span>
</code></pre>


  </div>
</div>
<div class="tags">
  

</div>
  
    <h2>
      Constant Summary
      <small><a href="#" class="constants_summary_toggle">collapse</a></small>
    </h2>

    <dl class="constants">
      
        <dt id="EXTENDED-constant" class="">EXTENDED =
          <div class="docstring">
  <div class="discussion">
    <p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>UNKNOWN_VALUE</span></pre></dd>
      
        <dt id="FIXEDENCODING-constant" class="">FIXEDENCODING =
          <div class="docstring">
  <div class="discussion">
    <p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>UNKNOWN_VALUE</span></pre></dd>
      
        <dt id="IGNORECASE-constant" class="">IGNORECASE =
          <div class="docstring">
  <div class="discussion">
    <p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>UNKNOWN_VALUE</span></pre></dd>
      
        <dt id="MULTILINE-constant" class="">MULTILINE =
          <div class="docstring">
  <div class="discussion">
    <p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>UNKNOWN_VALUE</span></pre></dd>
      
        <dt id="NOENCODING-constant" class="">NOENCODING =
          <div class="docstring">
  <div class="discussion">
    <p>see Regexp.options and Regexp.new</p>


  </div>
</div>
<div class="tags">
  

</div>
        </dt>
        <dd><pre class="code"><span class='const'>UNKNOWN_VALUE</span></pre></dd>
      
    </dl>
  







  
    <h2>
      Class Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#compile-class_method" title="compile (class method)">.<strong>compile</strong>  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Alias for Regexp.new.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#escape-class_method" title="escape (class method)">.<strong>escape</strong>(str)  &#x21d2; String </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Escapes any characters that would have special meaning in a regular expression.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#last_match-class_method" title="last_match (class method)">.<strong>last_match</strong>  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The first form returns the MatchData object generated by the last successful pattern match.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#quote-class_method" title="quote (class method)">.<strong>quote</strong>(str)  &#x21d2; String </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Escapes any characters that would have special meaning in a regular expression.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#try_convert-class_method" title="try_convert (class method)">.<strong>try_convert</strong>(obj)  &#x21d2; Regexp? </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Try to convert <em>obj</em> into a Regexp, using to_regexp method.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#union-class_method" title="union (class method)">.<strong>union</strong>  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Return a Regexp object that is the union of the given *pattern*s, i.e., will match any of its parts.</p>
</div></span>
  
</li>

      
    </ul>
  
    <h2>
      Instance Method Summary
      <small><a href="#" class="summary_toggle">collapse</a></small>
    </h2>

    <ul class="summary">
      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#==-instance_method" title="#== (instance method)">#<strong>==</strong>(other)  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Equality---Two regexps are equal if their patterns are identical, they have the same character set code, and their <code>casefold?</code> values are the same.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#===-instance_method" title="#=== (instance method)">#<strong>===</strong>(other)  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Case Equality---Used in case statements.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#=~-instance_method" title="#=~ (instance method)">#<strong>=~</strong>(str)  &#x21d2; Integer? </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Match---Matches <em>rxp</em> against <em>str</em>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#casefold%3F-instance_method" title="#casefold? (instance method)">#<strong>casefold?</strong>  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the value of the case-insensitive flag.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#encoding-instance_method" title="#encoding (instance method)">#<strong>encoding</strong>  &#x21d2; Encoding </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the Encoding object that represents the encoding of obj.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#eql%3F-instance_method" title="#eql? (instance method)">#<strong>eql?</strong>(other)  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Equality---Two regexps are equal if their patterns are identical, they have the same character set code, and their <code>casefold?</code> values are the same.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#fixed_encoding%3F-instance_method" title="#fixed_encoding? (instance method)">#<strong>fixed_encoding?</strong>  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns false if rxp is applicable to a string with any ASCII compatible encoding.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#hash-instance_method" title="#hash (instance method)">#<strong>hash</strong>  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Produce a hash based on the text and options of this regular expression.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#initialize-instance_method" title="#initialize (instance method)">#<strong>initialize</strong>  &#x21d2; Object </a>
    

    
  </span>
  
  
    <span class="note title constructor">constructor</span>
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Constructs a new regular expression from <code>pattern</code>, which can be either a String or a Regexp (in which case that regexp&#39;s options are propagated), and new options may not be specified (a change as of Ruby 1.8).</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#inspect-instance_method" title="#inspect (instance method)">#<strong>inspect</strong>  &#x21d2; String </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Produce a nicely formatted string-version of <em>rxp</em>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#match-instance_method" title="#match (instance method)">#<strong>match</strong>  &#x21d2; Object </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a MatchData object describing the match, or <code>nil</code> if there was no match.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#match%3F-instance_method" title="#match? (instance method)">#<strong>match?</strong>(str, pos = ?)  &#x21d2; Boolean </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a <code>true</code> or <code>false</code> indicates whether the regexp is matched or not without updating $~ and other related variables.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#named_captures-instance_method" title="#named_captures (instance method)">#<strong>named_captures</strong>  &#x21d2; ::Hash[String, ::Array[Integer]] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a hash representing information about named captures of <em>rxp</em>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#names-instance_method" title="#names (instance method)">#<strong>names</strong>  &#x21d2; ::Array[String] </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a list of names of captures as an array of strings.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#options-instance_method" title="#options (instance method)">#<strong>options</strong>  &#x21d2; Integer </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the set of bits corresponding to the options used when creating this Regexp (see Regexp::new for details. Note that additional bits may be set in the returned options: these are used internally by the regular expression code. These extra bits are ignored if the options are passed to Regexp::new.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#source-instance_method" title="#source (instance method)">#<strong>source</strong>  &#x21d2; String </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the original string of the pattern.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#to_s-instance_method" title="#to_s (instance method)">#<strong>to_s</strong>  &#x21d2; String </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns a string containing the regular expression and its options (using the <code>(?opts:source)</code> notation. This string can be fed back in to Regexp::new to a regular expression with the same semantics as the original. (However, <code>Regexp#==</code> may not return true when comparing the two, as the source of the regular expression itself may differ, as the example shows).  Regexp#inspect produces a generally more readable version of <em>rxp</em>.</p>
</div></span>
  
</li>

      
        <li class="public ">
  <span class="summary_signature">
    
      <a href="#~-instance_method" title="#~ (instance method)">#<strong>~</strong>  &#x21d2; Integer? </a>
    

    
  </span>
  
  
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Match---Matches <em>rxp</em> against the contents of <code>$_</code>.</p>
</div></span>
  
</li>

      
    </ul>
  

<div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <div class="method_details first">
  <h3 class="signature first" id="initialize-instance_method">
  
    
      <span class="overload">#<strong>initialize</strong>(string, options = ?,kcode=?))  &#x21d2; <tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt> </span>
    
      <span class="overload">#<strong>initialize</strong>(regexp)  &#x21d2; <tt>void</tt> </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Constructs a new regular expression from <code>pattern</code>, which can be either a
String or a Regexp (in which case that regexp&#39;s options are propagated), and
new options may not be specified (a change as of Ruby 1.8).</p>

<p>If <code>options</code> is an Integer, it should be one or more of the constants
Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, <em>or</em>-ed together.
 Otherwise, if <code>options</code> is not <code>nil</code> or <code>false</code>, the regexp will be case
insensitive.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r1'>r1</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>^a-z+:\\s+\w+</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; /^a-z+:\s+\w+/
</span><span class='id identifier rubyid_r2'>r2</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cat</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>true</span><span class='rparen'>)</span>     <span class='comment'>#=&gt; /cat/i
</span><span class='id identifier rubyid_r3'>r3</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='id identifier rubyid_r2'>r2</span><span class='rparen'>)</span>              <span class='comment'>#=&gt; /cat/i
</span><span class='id identifier rubyid_r4'>r4</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>dog</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span></span> <span class='op'>|</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span></span><span class='rparen'>)</span> <span class='comment'>#=&gt; /dog/ix
</span></code></pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">#<strong>initialize</strong>(string, options = ?,kcode=?))  &#x21d2; <tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>string</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>options</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>?,kcode=?)</tt>)</em>
      
      
    </li>
  
    <li>
      
        <span class='name'>kcode</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>


</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">#<strong>initialize</strong>(regexp)  &#x21d2; <tt>void</tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>regexp</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>


</div>
      </li>
    
  </ul>


</div>
</div>
  
</div>


  <div id="class_method_details" class="method_details_list">
    <h2>Class Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="compile-class_method">
  
    
      <span class="overload">.<strong>self.compile</strong>(string, options = ?,kcode=?))  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
    
      <span class="overload">.<strong>self.compile</strong>(regexp)  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Alias for Regexp.new</p>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.compile</strong>(string, options = ?,kcode=?))  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>string</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>options</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>?,kcode=?)</tt>)</em>
      
      
    </li>
  
    <li>
      
        <span class='name'>kcode</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.compile</strong>(regexp)  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>regexp</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="escape-class_method">
  
    .<strong>escape</strong>(str)  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string with the same or compatible encoding.
For any string, <code>Regexp.new(Regexp.escape(*str*))=~*str</code>* will be true.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_escape'>escape</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>\*?{}.</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>   <span class='comment'>#=&gt; \\\*\?\{\}\.
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span> | <span class='object_link'><a href="Symbol.html" title="Symbol (class)">Symbol</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="last_match-class_method">
  
    
      <span class="overload">.<strong>self.last_match</strong>  &#x21d2; <tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span>?</tt> </span>
    
      <span class="overload">.<strong>self.last_match</strong>(n)  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt> </span>
    
      <span class="overload">.<strong>self.last_match</strong>(n)  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt> </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>The first form returns the MatchData object generated by the last successful
pattern match.  Equivalent to reading the special global variable <code>$~</code> (see
Special global variables in Regexp for details).</p>

<p>The second form returns the <em>n*th field in this MatchData object. *n</em> can be a
string or symbol to reference a named capture.</p>

<p>Note that the last_match is local to the thread and method scope of the method
that did the pattern match.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>c(.)t</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cat</span><span class='tstring_end'>&#39;</span></span>        <span class='comment'>#=&gt; 0
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span>       <span class='comment'>#=&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span><span class='lparen'>(</span><span class='int'>0</span><span class='rparen'>)</span>    <span class='comment'>#=&gt; &quot;cat&quot;
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span><span class='lparen'>(</span><span class='int'>1</span><span class='rparen'>)</span>    <span class='comment'>#=&gt; &quot;a&quot;
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span><span class='lparen'>(</span><span class='int'>2</span><span class='rparen'>)</span>    <span class='comment'>#=&gt; nil
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>var = val</span><span class='tstring_end'>&quot;</span></span>
<span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span>       <span class='comment'>#=&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span><span class='lparen'>(</span><span class='symbol'>:lhs</span><span class='rparen'>)</span> <span class='comment'>#=&gt; &quot;var&quot;
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_last_match'>last_match</span><span class='lparen'>(</span><span class='symbol'>:rhs</span><span class='rparen'>)</span> <span class='comment'>#=&gt; &quot;val&quot;
</span></code></pre>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.last_match</strong>  &#x21d2; <tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span>?</tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.last_match</strong>(n)  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.last_match</strong>(n)  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>n</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Symbol.html" title="Symbol (class)">Symbol</a></span> | <span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="quote-class_method">
  
    .<strong>quote</strong>(str)  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Escapes any characters that would have special meaning in a regular
expression. Returns a new escaped string with the same or compatible encoding.
For any string, <code>Regexp.new(Regexp.escape(*str*))=~*str</code>* will be true.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_escape'><span class='object_link'><a href="#escape-class_method" title="Regexp.escape (method)">escape</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>\*?{}.</span><span class='tstring_end'>&#39;</span></span><span class='rparen'>)</span>   <span class='comment'>#=&gt; \\\*\?\{\}\.
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span> | <span class='object_link'><a href="Symbol.html" title="Symbol (class)">Symbol</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="try_convert-class_method">
  
    .<strong>try_convert</strong>(obj)  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span>?</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Try to convert <em>obj</em> into a Regexp, using to_regexp method. Returns converted
regexp or nil if <em>obj</em> cannot be converted for any reason.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_try_convert'>try_convert</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>re</span><span class='regexp_end'>/</span></span><span class='rparen'>)</span>         <span class='comment'>#=&gt; /re/
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_try_convert'>try_convert</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>re</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>         <span class='comment'>#=&gt; nil
</span>
<span class='id identifier rubyid_o'>o</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="BasicObject.html#initialize-instance_method" title="BasicObject#initialize (method)">new</a></span></span>
<span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_try_convert'>try_convert</span><span class='lparen'>(</span><span class='id identifier rubyid_o'>o</span><span class='rparen'>)</span>            <span class='comment'>#=&gt; nil
</span><span class='kw'>def</span> <span class='id identifier rubyid_o'>o</span><span class='period'>.</span><span class='id identifier rubyid_to_regexp'>to_regexp</span><span class='lparen'>(</span><span class='rparen'>)</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>foo</span><span class='regexp_end'>/</span></span> <span class='kw'>end</span>
<span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_try_convert'>try_convert</span><span class='lparen'>(</span><span class='id identifier rubyid_o'>o</span><span class='rparen'>)</span>            <span class='comment'>#=&gt; /foo/
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>obj</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="union-class_method">
  
    
      <span class="overload">.<strong>self.union</strong>  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
    
      <span class="overload">.<strong>self.union</strong>(pat1, *args)  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
    
      <span class="overload">.<strong>self.union</strong>  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Return a Regexp object that is the union of the given <em>pattern*s, i.e., will
match any of its parts. The *pattern*s can be Regexp objects, in which case
their options will be preserved, or Strings. If no patterns are given, returns
<code>/(?!)/</code>.  The behavior is unspecified if any given *pattern</em> contains
capture.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_union'>union</span>                         <span class='comment'>#=&gt; /(?!)/
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_union'>union</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>penzance</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>             <span class='comment'>#=&gt; /penzance/
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_union'>union</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>a+b*c</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>                <span class='comment'>#=&gt; /a\+b\*c/
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_union'>union</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>skiing</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>sledding</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>   <span class='comment'>#=&gt; /skiing|sledding/
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_union'>union</span><span class='lparen'>(</span><span class='lbracket'>[</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>skiing</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>sledding</span><span class='tstring_end'>&quot;</span></span><span class='rbracket'>]</span><span class='rparen'>)</span> <span class='comment'>#=&gt; /skiing|sledding/
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_union'>union</span><span class='lparen'>(</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>dogs</span><span class='regexp_end'>/</span></span><span class='comma'>,</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cats</span><span class='regexp_end'>/i</span></span><span class='rparen'>)</span>        <span class='comment'>#=&gt; /(?-mix:dogs)|(?i-mx:cats)/
</span></code></pre>

<p>Note: the arguments for ::union will try to be converted into a regular
expression literal via #to_regexp.</p>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.union</strong>  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.union</strong>(pat1, *args)  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>pat1</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span> | <span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">.<strong>self.union</strong>  &#x21d2; <tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'></span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">::Array</a></span>[<span class='object_link'><a href="String.html" title="String (class)">String</a></span> | <span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span>]</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div>
</div>
    
  </div>

  <div id="instance_method_details" class="method_details_list">
    <h2>Instance Method Details</h2>

    
      <div class="method_details first">
  <h3 class="signature first" id="==-instance_method">
  
    #<strong>==</strong>(other)  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Equality---Two regexps are equal if their patterns are identical, they have
the same character set code, and their <code>casefold?</code> values are the same.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/</span></span>  <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/x</span></span>   <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/</span></span>  <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/i</span></span>   <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/</span></span>  <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/u</span></span>   <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/u</span></span> <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/n</span></span>   <span class='comment'>#=&gt; false
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>other</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="===-instance_method">
  
    #<strong>===</strong>(other)  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Case Equality---Used in case statements.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_a'>a</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>case</span> <span class='id identifier rubyid_a'>a</span>
<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A[a-z]*\z</span><span class='regexp_end'>/</span></span><span class='semicolon'>;</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Lower case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>when</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\A[A-Z]*\z</span><span class='regexp_end'>/</span></span><span class='semicolon'>;</span> <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Upper case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>else</span><span class='semicolon'>;</span>              <span class='id identifier rubyid_print'>print</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Mixed case\n</span><span class='tstring_end'>&quot;</span></span>
<span class='kw'>end</span>
<span class='comment'>#=&gt; &quot;Upper case&quot;
</span></code></pre>

<p>Following a regular expression literal with the #=== operator allows you to
compare against a String.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[a-z]*$</span><span class='regexp_end'>/</span></span> <span class='op'>===</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&quot;</span></span> <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>^[A-Z]*$</span><span class='regexp_end'>/</span></span> <span class='op'>===</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>HELLO</span><span class='tstring_end'>&quot;</span></span> <span class='comment'>#=&gt; true
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>other</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="=~-instance_method">
  
    #<strong>=~</strong>(str)  &#x21d2; <tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span>?</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Match---Matches <em>rxp</em> against <em>str</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>at</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>input data</span><span class='tstring_end'>&quot;</span></span>   <span class='comment'>#=&gt; 7
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ax</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>input data</span><span class='tstring_end'>&quot;</span></span>   <span class='comment'>#=&gt; nil
</span></code></pre>

<p>If <code>=~</code> is used with a regexp literal with named captures, captured strings
(or nil) is assigned to local variables named by the capture names.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span>    <span class='comment'>#=&gt; &quot;x&quot;
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_rhs'>rhs</span>    <span class='comment'>#=&gt; &quot;y&quot;
</span></code></pre>

<p>If it is not matched, nil is assigned for the variables.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  x = </span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span>    <span class='comment'>#=&gt; nil
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_rhs'>rhs</span>    <span class='comment'>#=&gt; nil
</span></code></pre>

<p>This assignment is implemented in the Ruby parser. The parser detects
&#39;regexp-literal =~ expression&#39; for the assignment. The regexp must be a
literal without interpolation and placed at left hand side.</p>

<p>The assignment does not occur if the regexp is not a literal.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_re'>re</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_re'>re</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span>    <span class='comment'># undefined local variable
</span><span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_rhs'>rhs</span>    <span class='comment'># undefined local variable
</span></code></pre>

<p>A regexp interpolation, <code>#{}</code>, also disables the assignment.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_rhs_pat'>rhs_pat</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*</span><span class='embexpr_beg'>#{</span><span class='id identifier rubyid_rhs_pat'>rhs_pat</span><span class='embexpr_end'>}</span><span class='regexp_end'>/</span></span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>x = y</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span>    <span class='comment'># undefined local variable
</span></code></pre>

<p>The assignment does not occur if the regexp is placed at the right hand side.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>  x = y  </span><span class='tstring_end'>&quot;</span></span> <span class='op'>=~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_p'>p</span> <span class='id identifier rubyid_lhs'>lhs</span><span class='comma'>,</span> <span class='id identifier rubyid_rhs'>rhs</span> <span class='comment'># undefined local variable
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="casefold?-instance_method">
  
    #<strong>casefold?</strong>  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the value of the case-insensitive flag.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_casefold?'>casefold?</span>           <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/i</span></span><span class='period'>.</span><span class='id identifier rubyid_casefold?'>casefold?</span>          <span class='comment'>#=&gt; true
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?i:a)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_casefold?'>casefold?</span>      <span class='comment'>#=&gt; false
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="encoding-instance_method">
  
    #<strong>encoding</strong>  &#x21d2; <tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the Encoding object that represents the encoding of obj.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Encoding.html" title="Encoding (class)">Encoding</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="eql?-instance_method">
  
    #<strong>eql?</strong>(other)  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Equality---Two regexps are equal if their patterns are identical, they have
the same character set code, and their <code>casefold?</code> values are the same.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/</span></span>  <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/x</span></span>   <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/</span></span>  <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/i</span></span>   <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/</span></span>  <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/u</span></span>   <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/u</span></span> <span class='op'>==</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>abc</span><span class='regexp_end'>/n</span></span>   <span class='comment'>#=&gt; false
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>other</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Object.html" title="Object (class)">Object</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="fixed_encoding?-instance_method">
  
    #<strong>fixed_encoding?</strong>  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns false if rxp is applicable to a string with any ASCII compatible
encoding. Returns true otherwise.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_fixed_encoding?'>fixed_encoding?</span>                               <span class='comment'>#=&gt; false
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{6666} a</span><span class='tstring_end'>&quot;</span></span>                               <span class='comment'>#=&gt; 2
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xa1\xa2 a</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>      <span class='comment'>#=&gt; 2
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>             <span class='comment'>#=&gt; 0
</span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>a</span><span class='regexp_end'>/u</span></span>
<span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_fixed_encoding?'>fixed_encoding?</span>                               <span class='comment'>#=&gt; true
</span><span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_encoding'>encoding</span>                                      <span class='comment'>#=&gt; #&lt;Encoding:UTF-8&gt;
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{6666} a</span><span class='tstring_end'>&quot;</span></span>                               <span class='comment'>#=&gt; 2
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xa1\xa2</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>        <span class='comment'>#=&gt; Encoding::CompatibilityError
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>             <span class='comment'>#=&gt; 0
</span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\u{6666}</span><span class='regexp_end'>/</span></span>
<span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_fixed_encoding?'>fixed_encoding?</span>                               <span class='comment'>#=&gt; true
</span><span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_encoding'>encoding</span>                                      <span class='comment'>#=&gt; #&lt;Encoding:UTF-8&gt;
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\u{6666} a</span><span class='tstring_end'>&quot;</span></span>                               <span class='comment'>#=&gt; 0
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>\xa1\xa2</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>        <span class='comment'>#=&gt; Encoding::CompatibilityError
</span><span class='id identifier rubyid_r'>r</span> <span class='op'>=~</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='period'>.</span><span class='id identifier rubyid_force_encoding'>force_encoding</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>euc-jp</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>             <span class='comment'>#=&gt; nil
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="hash-instance_method">
  
    #<strong>hash</strong>  &#x21d2; <tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Produce a hash based on the text and options of this regular expression.</p>

<p>See also Object#hash.</p>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="inspect-instance_method">
  
    #<strong>inspect</strong>  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Produce a nicely formatted string-version of <em>rxp</em>. Perhaps surprisingly,
<code>#inspect</code> actually produces the more natural version of the string than
<code>#to_s</code>.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span><span class='period'>.</span><span class='id identifier rubyid_inspect'>inspect</span>        <span class='comment'>#=&gt; &quot;/ab+c/ix&quot;
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="match-instance_method">
  
    
      <span class="overload">#<strong>match</strong>(str, pos = ?))  &#x21d2; <tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span>?</tt> </span>
    
      <span class="overload">#<strong>match</strong>(str, pos = ?)) {|| ... } &#x21d2; <tt>T?</tt> </span>
    
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a MatchData object describing the match, or <code>nil</code> if there was no
match. This is equivalent to retrieving the value of the special variable <code>$~</code>
following a normal match.  If the second parameter is present, it specifies
the position in the string to begin the search.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)(.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='int'>2</span><span class='rbracket'>]</span>   <span class='comment'>#=&gt; &quot;b&quot;
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>abc</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>1</span><span class='rparen'>)</span><span class='lbracket'>[</span><span class='int'>2</span><span class='rbracket'>]</span>   <span class='comment'>#=&gt; &quot;c&quot;
</span></code></pre>

<p>If a block is given, invoke the block with MatchData if match succeed, so that
you can write</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>M(.*)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Matz</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_m'>m</span><span class='op'>|</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_m'>m</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_m'>m</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</code></pre>

<p>instead of</p>

<pre class="code ruby"><code class="ruby"><span class='kw'>if</span> <span class='id identifier rubyid_m'>m</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>M(.*)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match'>match</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Matz</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_m'>m</span><span class='lbracket'>[</span><span class='int'>0</span><span class='rbracket'>]</span>
  <span class='id identifier rubyid_puts'>puts</span> <span class='id identifier rubyid_m'>m</span><span class='lbracket'>[</span><span class='int'>1</span><span class='rbracket'>]</span>
<span class='kw'>end</span>
</code></pre>

<p>The return value is a value from block execution in this case.</p>


  </div>
</div>
<div class="tags">
  
  <p class="tag_title">Overloads:</p>
  <ul class="overload">
    
      
      <li class="overload_item">
        <span class="signature">#<strong>match</strong>(str, pos = ?))  &#x21d2; <tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span>?</tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>? | <span class='object_link'><a href="Symbol.html" title="Symbol (class)">Symbol</a></span> | <span class='object_link'>_ToStr</span></tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>pos</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>?)</tt>)</em>
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
      
      <li class="overload_item">
        <span class="signature">#<strong>match</strong>(str, pos = ?)) {|| ... } &#x21d2; <tt>T?</tt> </span>
        <div class="docstring">
  <div class="discussion">
    

  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>? | <span class='object_link'><a href="Symbol.html" title="Symbol (class)">Symbol</a></span> | <span class='object_link'>_ToStr</span></tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>pos</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>?)</tt>)</em>
      
      
    </li>
  
</ul>

<p class="tag_title">Yield Parameters:</p>
<ul class="yieldparam">
  
    <li>
      
        <span class='name'></span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="MatchData.html" title="MatchData (class)">MatchData</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>
<p class="tag_title">Yield Returns:</p>
<ul class="yieldreturn">
  
    <li>
      
      
        <span class='type'>(<tt>T</tt>)</span>
      
      
      
    </li>
  
</ul>
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>T?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
      </li>
    
  </ul>


</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="match?-instance_method">
  
    #<strong>match?</strong>(str, pos = ?)  &#x21d2; <tt>Boolean</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a <code>true</code> or <code>false</code> indicates whether the regexp is matched or not
without updating $~ and other related variables. If the second parameter is
present, it specifies the position in the string to begin the search.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>R...</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match?'>match?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>    <span class='comment'>#=&gt; true
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>R...</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match?'>match?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby</span><span class='tstring_end'>&quot;</span></span><span class='comma'>,</span> <span class='int'>1</span><span class='rparen'>)</span> <span class='comment'>#=&gt; false
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>P...</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_match?'>match?</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Ruby</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>    <span class='comment'>#=&gt; false
</span><span class='backref'>$&amp;</span>                       <span class='comment'>#=&gt; nil
</span></code></pre>


  </div>
</div>
<div class="tags">
  <p class="tag_title">Parameters:</p>
<ul class="param">
  
    <li>
      
        <span class='name'>str</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span>? | <span class='object_link'><a href="Symbol.html" title="Symbol (class)">Symbol</a></span> | <span class='object_link'>_ToStr</span></tt>)</span>
      
      
      
    </li>
  
    <li>
      
        <span class='name'>pos</span>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
        <em class="default">(defaults to: <tt>?</tt>)</em>
      
      
    </li>
  
</ul>

<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt>Boolean</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="named_captures-instance_method">
  
    #<strong>named_captures</strong>  &#x21d2; <tt><span class='object_link'><a href="Hash.html" title="Hash (class)">::Hash</a></span>[<span class='object_link'><a href="String.html" title="String (class)">String</a></span>, <span class='object_link'><a href="Array.html" title="Array (class)">::Array</a></span>[<span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span>]]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a hash representing information about named captures of <em>rxp</em>.</p>

<p>A key of the hash is a name of the named captures. A value of the hash is an
array which is list of indexes of corresponding named captures.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;bar&gt;.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_named_captures'>named_captures</span>
<span class='comment'>#=&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;foo&gt;.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_named_captures'>named_captures</span>
<span class='comment'>#=&gt; {&quot;foo&quot;=&gt;[1, 2]}
</span></code></pre>

<p>If there are no named captures, an empty hash is returned.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_named_captures'>named_captures</span>
<span class='comment'>#=&gt; {}
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Hash.html" title="Hash (class)">::Hash</a></span>[<span class='object_link'><a href="String.html" title="String (class)">String</a></span>, <span class='object_link'><a href="Array.html" title="Array (class)">::Array</a></span>[<span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span>]]</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="names-instance_method">
  
    #<strong>names</strong>  &#x21d2; <tt><span class='object_link'><a href="Array.html" title="Array (class)">::Array</a></span>[<span class='object_link'><a href="String.html" title="String (class)">String</a></span>]</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a list of names of captures as an array of strings.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_names'>names</span>
<span class='comment'>#=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(?&lt;foo&gt;.)(?&lt;foo&gt;.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_names'>names</span>
<span class='comment'>#=&gt; [&quot;foo&quot;]
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>(.)(.)</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_names'>names</span>
<span class='comment'>#=&gt; []
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Array.html" title="Array (class)">::Array</a></span>[<span class='object_link'><a href="String.html" title="String (class)">String</a></span>]</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="options-instance_method">
  
    #<strong>options</strong>  &#x21d2; <tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the set of bits corresponding to the options used when creating this
Regexp (see Regexp::new for details. Note that additional bits may be set in
the returned options: these are used internally by the regular expression
code. These extra bits are ignored if the options are passed to Regexp::new.</p>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#IGNORECASE-constant" title="Regexp::IGNORECASE (constant)">IGNORECASE</a></span></span>                  <span class='comment'>#=&gt; 1
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#EXTENDED-constant" title="Regexp::EXTENDED (constant)">EXTENDED</a></span></span>                    <span class='comment'>#=&gt; 2
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="#MULTILINE-constant" title="Regexp::MULTILINE (constant)">MULTILINE</a></span></span>                   <span class='comment'>#=&gt; 4
</span>
<span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cat</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_options'>options</span>                       <span class='comment'>#=&gt; 0
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cat</span><span class='regexp_end'>/ix</span></span><span class='period'>.</span><span class='id identifier rubyid_options'>options</span>                     <span class='comment'>#=&gt; 3
</span><span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&#39;</span><span class='tstring_content'>cat</span><span class='tstring_end'>&#39;</span></span><span class='comma'>,</span> <span class='kw'>true</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_options'>options</span>     <span class='comment'>#=&gt; 1
</span><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\xa1\xa2</span><span class='regexp_end'>/e</span></span><span class='period'>.</span><span class='id identifier rubyid_options'>options</span>                 <span class='comment'>#=&gt; 16
</span>
<span class='id identifier rubyid_r'>r</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>cat</span><span class='regexp_end'>/ix</span></span>
<span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span><span class='comma'>,</span> <span class='id identifier rubyid_r'>r</span><span class='period'>.</span><span class='id identifier rubyid_options'>options</span><span class='rparen'>)</span>     <span class='comment'>#=&gt; /cat/ix
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="source-instance_method">
  
    #<strong>source</strong>  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the original string of the pattern.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span> <span class='comment'>#=&gt; &quot;ab+c&quot;
</span></code></pre>

<p>Note that escape sequences are retained as is.</p>

<pre class="code ruby"><code class="ruby"><span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>\x20\+</span><span class='regexp_end'>/</span></span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span>  <span class='comment'>#=&gt; &quot;\\x20\\+&quot;
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="to_s-instance_method">
  
    #<strong>to_s</strong>  &#x21d2; <tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns a string containing the regular expression and its options (using the
<code>(?opts:source)</code> notation. This string can be fed back in to Regexp::new to a
regular expression with the same semantics as the original. (However,
<code>Regexp#==</code> may not return true when comparing the two, as the source of the
regular expression itself may differ, as the example shows).  Regexp#inspect
produces a generally more readable version of <em>rxp</em>.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_r1'>r1</span> <span class='op'>=</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>ab+c</span><span class='regexp_end'>/ix</span></span>           <span class='comment'>#=&gt; /ab+c/ix
</span><span class='id identifier rubyid_s1'>s1</span> <span class='op'>=</span> <span class='id identifier rubyid_r1'>r1</span><span class='period'>.</span><span class='id identifier rubyid_to_s'>to_s</span>            <span class='comment'>#=&gt; &quot;(?ix-m:ab+c)&quot;
</span><span class='id identifier rubyid_r2'>r2</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="" title="Regexp (class)">Regexp</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'><span class='object_link'><a href="#initialize-instance_method" title="Regexp#initialize (method)">new</a></span></span><span class='lparen'>(</span><span class='id identifier rubyid_s1'>s1</span><span class='rparen'>)</span>     <span class='comment'>#=&gt; /(?ix-m:ab+c)/
</span><span class='id identifier rubyid_r1'>r1</span> <span class='op'>==</span> <span class='id identifier rubyid_r2'>r2</span>                <span class='comment'>#=&gt; false
</span><span class='id identifier rubyid_r1'>r1</span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span>               <span class='comment'>#=&gt; &quot;ab+c&quot;
</span><span class='id identifier rubyid_r2'>r2</span><span class='period'>.</span><span class='id identifier rubyid_source'>source</span>               <span class='comment'>#=&gt; &quot;(?ix-m:ab+c)&quot;
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="String.html" title="String (class)">String</a></span></tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
      <div class="method_details ">
  <h3 class="signature " id="~-instance_method">
  
    #<strong>~</strong>  &#x21d2; <tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span>?</tt> 
  

  

  
</h3><div class="docstring">
  <div class="discussion">
    <p>Match---Matches <em>rxp</em> against the contents of <code>$_</code>. Equivalent to <em>`rxp</em> =~
$_`.</p>

<pre class="code ruby"><code class="ruby"><span class='gvar'>$_</span> <span class='op'>=</span> <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>input data</span><span class='tstring_end'>&quot;</span></span>
<span class='op'>~</span> <span class='tstring'><span class='regexp_beg'>/</span><span class='tstring_content'>at</span><span class='regexp_end'>/</span></span>   <span class='comment'>#=&gt; 7
</span></code></pre>


  </div>
</div>
<div class="tags">
  
<p class="tag_title">Returns:</p>
<ul class="return">
  
    <li>
      
      
        <span class='type'>(<tt><span class='object_link'><a href="Integer.html" title="Integer (class)">Integer</a></span>?</tt>)</span>
      
      
      
    </li>
  
</ul>

</div>
</div>
    
  </div>

</div>

      <div id="footer">
  Generated on Fri Dec 25 20:29:33 2020 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.25 (ruby-2.6.5).
</div>

    </div>
  </body>
</html>